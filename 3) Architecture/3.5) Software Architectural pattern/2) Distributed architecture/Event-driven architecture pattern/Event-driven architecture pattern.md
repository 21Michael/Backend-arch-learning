# 2) Event-driven architecture pattern
The event-driven architecture pattern is a popular distributed asynchronous architecture pattern used 
to produce highly scalable applications. It is also highly adaptable and can be used for small
applications and as well as large, complex ones. The event-driven architecture is made up of highly 
decoupled, single-purpose event processing components that asynchronously receive and process events.

## Concepts:
  - ### Mediator  
    The mediator topology is useful for events that have multiple steps and require some level of 
    orchestration to process the event.  
    __   
    **<ins>For example:</ins>** a single event to place a stock trade might require
    you to **1) first validate the trade,** then **2) check the compliance of that stock trade
    against various compliance rules**, **3) assign the trade to a broker,** **4) calculate the commission,**
    and **5) finally place the trade with that broker.** All of these steps would require some level 
    of orchestration to determine the order of the steps and which ones can be done serially and in parallel.  
    __   
    **<ins>There are four main types of architecture components within the mediator topology:</ins>**
      - **Event:**  
        There are two types of events within this pattern:
          - **Initial event:** the original event received by the mediator;
          - **Processing event:** are ones that are generated by the mediator and received by the 
            event-processing components;
      - **Event queues: (queue)** used to transport the event to the event mediator; It is common to 
        have anywhere from a dozen to several hundred event queues in an event-driven architecture. 
        The pattern does not specify the implementation of the event queue component; it
        can be a message queue, a web service endpoint, or any combination thereof.
      - **Event mediator (router):** receives the initial event and orchestrates that event by sending additional 
        asynchronous events to event channels;
      - **Event channels (queue):** execute each step of the process;
      - **Event processors (observer):** listen on the event channels, receive the event from the event mediator 
        and execute specific business logic to process the event; The event channels can be either
        message queues or message topics, although message topics are most widely used with the mediator
        topology so that processing events can be processed by multiple event processors (each 
        performing a different task based on the processing event received); Contain the application
        business logic necessary to process the processing event. Event processors are
        self-contained, independent, highly decoupled architecture components that perform a specific 
        task in the application or system. Each event-processor component should perform a single 
        business task and not rely on other event processors to complete its specific task.
        
    ![link](https://miro.medium.com/max/1050/0*aqkwbPRXOJHQTdFL.png)
    
    **Example:**
    To illustrate how the mediator topology works, suppose you are
    insured through an insurance company and you decide to move. In
    this case, the initial event might be called something like relocation
    event. The steps involved in processing a relocation event are con‐
    tained within the event mediator as shown in Figure 2-2. For each
    initial event step, the event mediator creates a processing event (e.g.,
    change address, recalc quote, etc.), sends that processing event to the
    event channel and waits for the processing event to be processed by
    the corresponding event processor (e.g., customer process, quote
    process, etc.). This process continues until all of the steps in the ini‐
    tial event have been processed. The single bar over the recalc quote
    and update claims steps in the event mediator indicates that these
    steps can be run at the same time.
    ![link](https://www.oreilly.com/library/view/building-evolutionary-architectures/9781491986356/assets/evar_0409.png)
    
  - ### Broker  
    The broker topology differs from the mediator topology in that there is no central event mediator; 
    rather, the message flow is distributed across the event processor components in a chain-like
    fashion through a lightweight message broker (e.g., ActiveMQ, HornetQ, etc.). This topology is 
    useful when you have a relatively simple event processing flow and you do not want (or need) central
    event orchestration.  
    __   
    **There are two main types of architecture components within the broker topology:**
       - **Broker component:**  The broker component can be centralized or federated and
         contains all of the event channels that are used within the event flow.
       - **Event processor component:** The event channels contained within the broker component can be
         message queues, message topics, or a combination of both.  
           
    ![link](https://miro.medium.com/max/1050/0*iGkuegluZ0UhcRGC.png)
    
    **Example:**
    Since there is no central event mediator to receive the initial event in
    the broker topology, the customer-process component receives the
    event directly, changes the customer address, and sends out an event
    saying it changed a customer’s address (e.g., change address event).
    In this example, there are two event processors that are interested in
    the change address event: the quote process and the claims process.
    The quote processor component recalculates the new autoinsurance rates based on the address change and publishes an event
    to the rest of the system indicating what it did (e.g., recalc quote
    event). The claims processing component, on the other hand,
    receives the same change address event, but in this case, it updates an
    outstanding insurance claim and publishes an event to the system as
    an update claim event. These new events are then picked up by other
    event processor components, and the event chain continues through
    the system until there are no more events are published for that par‐
    ticular initiating event.
    
    ![link](https://www.oreilly.com/content/wp-content/uploads/sites/2/2020/01/sapr_0204-a9ba9df2783fb4f6627debd1fc21a8fd.png)
    
    **Example 2 (Event bus):**  
    There are a couple of ways to implement event-driven pattern to your stack. One of them is 
    using “Broker Topology”. In broker topology, you send events to a central broker and all 
    subscribers of these broker receive and process events asynchronously.
    
    ![link](https://miro.medium.com/max/1400/1*afKDwjre2y0Aqw-VBy--mA.png)

## Event-driven architecture pros:
  - ### Flexibility
  - ### Easy to deploy
  - ### High performance by async flow
  - ### Easy to scale
  - ### Easy unit testing

## Event-driven architecture cons:
  - ### Difficult gateway testing
  - ### Difficult to develop

## Conclusion:

|CONCEPT|RATING|ANALISIS|
|-------|------|--------|
|**Overall agility (flexibility)**|High|Overall agility is the ability to respond quickly to a constantly changing environment. Since event-processor components are single-purpose and completely decoupled from other event processor components, changes are generally isolated to one or a few event processors and can be made quickly without impacting other components.|
|**Ease of deployment**|High|Overall this pattern is relatively easy to deploy due to the decoupled nature of the event-processor components. The broker topology tends to be easier to deploy than the mediator topology, primarily because the event mediator component is somewhat tightly coupled to the event processors: a change in an event processor component might also require a change in the event mediator, requiring both to be deployed for any given change.|
|**Testability**|Low|While individual unit testing is not overly difficult, it does require some sort of specialized testing client or testing tool to generate events. Testing is also complicated by the asynchronous nature of this pattern.|
|**Performance**|High|While it is certainly possible to implement an eventdriven architecture that does not perform well due to all the messaging infrastructure involved, in general, the pattern achieves high performance through its asynchronous capabilities; in other words, the ability to perform decoupled, parallel asynchronous operations outweighs the cost of queuing and dequeuing messages.|
|**Scalability**|High|Scalability is naturally achieved in this pattern through highly independent and decoupled event processors. Each event processor can be scaled separately, allowing for fine-grained scalability.|
|**Ease of development**|Low|Development can be somewhat complicated due to the asynchronous nature of the pattern as well as contract creation and the need for more advanced error handling conditions within the code for unresponsive event processors and failed brokers|
